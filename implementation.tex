\vspace{-0.5em}
\section{Implementation\label{sec:Implementation}}

In this section, we present our prototype of the eVFS API and discuss our implementation of the API. Next, we describe the in-place file system conversion tool that we have built using the eVFS interface.

Table~\ref{tab:evfs-api} shows a partial set of functions in the eVFS API. These functions provide fine-grained control by allowing extents, inodes, and directory entries, to be individually manipulated. We chose to use extent-based representation for storage space since it generally requires less metadata than the corresponding block-based representation, and is thus preferred by modern file systems. An application is expected to start a transaction before issuing most eVFS operations. 

%% Ashvin - this is not saying anything too interesting: An extent is written in the form of \{\textit{addr}, \textit{len}\}, where \textit{addr} is the block address of the extent, and \textit{len} is the number of blocks that the extent occupies.

We have implemented a subset of the eVFS API for two file systems, the extent-based Ext4 file system, and the log-structured F2FS file system, which enables converting an Ext4 file system to an F2FS file system. Our current implementation only works for offline use, i.e., the application has exclusive access to the unmounted file system. The file-system specific implementation of the API uses the Spiffy framework~\cite{sun2018spiffy} that provides robust parsing and serialization libraries, helping avoid bugs while handling file system metadata.

\vspace{-0.5em}
\subsection{File System Conversion Tool\label{subsec:conversion_tool}}

Converting an existing file system to a different file system is a tedious and time-consuming process that normally involves copying the full content of a file system to another disk, reformatting the disk, and then copying everything back to the new file system. In contrast, an in-place file system conversion only updates file system metadata, and does not move any regular file data unless its location must be used by statically allocated metadata of the destination file system. This technique can speed up the conversion dramatically. While some such conversion tools exist, they are hard to implement correctly\footnote{e.g. the \texttt{convertfs} utility \cite{convertfs} requires sparse file support on the source file system and performs full data copying} and not generally available.

We have designed and implemented a crash-consistent, in-place file system conversion tool using the eVFS interface. To do so, the conversion tool uses user-level, block-based redo journaling for ensuring crash consistency. Unlike typical journals that have a fixed size (e.g., the Ext4 journal), the journal is dynamically allocated from blocks that are currently free in both the source and the destination file systems, which ensures that both abort and redo recovery are possible since these blocks are not in use by either file system. The free space information is obtained by using the eVFS API. The dynamic allocation of blocks also allows converting heavily fragmented file systems, and maximizing utilization of the free space for the journal.

As an optimization, when a destination file system block is written to free space in the source file system, the block is written directly without being journaled. By journaling the rest of the blocks that will overwrite the source file system, we ensure crash consistency.

A complication occurs when a block that is currently in use by the journal is allocated to the destination file system. Allocating this block would cause the journal to be overwritten during checkpointing. In this case, the conflicting journal block is remapped to a different free block, and then this freed block can be updated directly.

If the journaling layer runs out of free space, the conversion process is aborted. We guarantee that this error occurs before the transaction commits. Therefore, no data loss is possible on a conversion failure. This guarantee enables streaming metadata read from the source file system while writing metadata for the destination file system. Without journaling, the metadata of the file system may be overwritten and thus all metadata must be fully read into memory before commencing the conversion. Therefore, journaling also helps reduce memory overhead, which is essential for converting large file system images.
 
The conversion tool starts a new transaction and then creates an empty destination file system on the device storing the source file system. Next it iterates through the inodes of the source file system, and creates the corresponding inodes in the destination file system. For a regular file, it iterates through each extent in the source inode, allocating the corresponding extent in the destination file system, and then copying over the mappings to the destination inode. For a source file system extent, we also check whether it overlaps with block(s) that are allocated in the destination file system. If so, we relocate the extent to free space in the destination file system, and update the source inode that maps to this extent. For directories, we iterate through the entries to recreate them in the destination file system. Then we commit the transaction and allow checkpointing to create the destination file system. The commit information needs to be located in a well-known location that is not in use by either file system. Currently, we use the boot record to store this information.

File systems sometimes inline data inside metadata (e.g., Ext4's fast symlink) or perform subblock allocation (e.g., ReiserFS's tail packing). The conversion tool can detect these cases through the eVFS interface, and it would instead read the content of the inode through a function similiar to the regular VFS \texttt{read} and rebuild the content using the equivalent of VFS \texttt{write} for the destination file system.

When converting to a file system that lacks the feature of the source file system, suitable defaults are used if possible, but some information may be lost as a result. For example, converting a file system with immutable snapshots to Ext4 will result in a copy of the snapshots being created, since Ext4 does not support snapshots. Similarly, converting a file system with quota support to one that does not will result in the loss of quota-related metadata.

%Data relocation involves reading the extent from the source file system and writing it to the destination file system.



