\vspace{-0.75em}
\section{Related Work\label{sec:Related_Work}}

We had previously built a file system conversion tool using the Spiffy framework~\cite{sun2018spiffy}. Spiffy uses an annotation language to enable complete specification of the file system format and then generates a robust library for parsing and serializing the file system data structures. However, Spiffy only helps identify the types of these structures, and not their semantics, and thus still requires significant file-system specific code. In contrast, the eVFS interface is generic across file systems. In this work, we use Spiffy for the file-system specific implementation of the eVFS API, thus ensuring a robust implementation.

%We had previously built a file system conversion tool using the Spiffy framework~\cite{sun2018spiffy}. Spiffy uses an annotation language to enable complete specification of the file system format, and uses annotated file system structure definitions to generate a library. This library provides parsing and serialization routines, and thus helps simplify processing file systems metadata via generic traversal functions, and building more robust applications. However, applications written using Spiffy are still file-system specific, since Spiffy only helps identify the types of file system structures, and not the semantics of the structures and their fields. Furthermore, applications that require initializing and updating file-system specific structures require significant file-system specific code. Therefore, writing Spiffy applications still requires significant effort. In contrast, the eVFS interface is truly generic across file systems; applications can be written in a fully file-system agnostic manner. In this work, we use Spiffy for the file-system specific implementation of the eVFS API, thus ensuring a robust implementation.

There are several libraries for accessing and manipulating file systems, such as \texttt{libext2fs}~\cite{tso-e2fsprogs} and \texttt{libfsntfs} that comes with \texttt{ntfsprogs}~\cite{mathes2007ntfs}. While most of the functions provided by these libraries are file-system specific, some are generic across file systems, such as iterating through all inodes in the file system, which we have adapted for the eVFS interface.

The \texttt{DeviceIoControl} function in the Win32 API supports many control codes that enable fine-grained changes to the file system and its resources. For example, \texttt{FSCTL\_MOVE\_FILE} allows for atomic remapping of a file's blocks~\cite{win32-defrag}. The Win32 file and volume management API ensures that each operation results in a consistent file system state. In contrast, eVFS operations can cause resource leaks or inconsistency when used incorrect. However, eVFS enables more powerful file system management applications, such as the conversion tool. 

%Many parallel file systems use a dedicated metadata service backed by an object storage service that provides persistence for both file data and file system metadata~\cite{schwan2003lustre}. With namespace management decoupled from the data path, clients can stream data to the storage servers, thus maximizing I/O bandwidth~\cite{weil2006ceph}. While these object stores conceptually split the VFS API across metadata and data operations, the eVFS API splits the operations themselves.

%Many existing works extended storage interfaces to simplify writing file systems, while improving their reliability, security, durability, functionality, or performance. A type-safe disk~\cite{Sivathanu06} extends the disk interface by exposing primitives for block allocation and pointer relationships, which helps enforce invariants such as preventing access to unallocated blocks.  Nameless writes~\cite{zhang2012nameless} allow the device to control block allocation decisions, which improves garbage collection and wear leveling of solid-state drives. Isotope~\cite{shin2016isotope} is a block-level store that supports ACID transactions over block reads and writes, simplifying the design of higher-level transactional applications, or supporting applications that need to use different systems, such as a file system and a database. Range writes~\cite{anand08rangewrites} allow the file system to specify a set of addresses at which to write a block. The disk can then make the optimal choice and return the address it picked.

Many existing works extended storage interfaces to simplify writing file systems, while improving their reliability~\cite{Sivathanu06}, security, functionality~\cite{shin2016isotope}, or performance~\cite{zhang2012nameless,anand08rangewrites}. Our work is similar in spirit to these works in that we have extended the file system interface to reduce the effort of building file system management applications. However, instead of pushing the decision making down to the lower layer, we instead expose previously internal operations in the file system, thus enabling applications that require more fine-grained control over the file system.

\vspace{-1ex}
